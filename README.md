wLua2是一个轻量级的Unity的lua嵌入方案。目前代码自动生成模块暂时还没时间完成，其他模块基本可以了。

1. 异常安全
	1）对于几乎所有能抛出异常的lua CAPI进行pcall封装,封装后的函数以wlua_开头，通过返回值，让调用者自行决定处理逻辑（这部分请参见wlua.c)
	2）将Mono异常和lua异常严格控制的各自一边，Mono端调用lua时只会触发c#异常，lua端调用c#时只会触发lua异常
2. 精简轻便，对初学者友好
	本人坚持认为，将游戏逻辑从c#迁移至lua，语言的改变意味着编程思维的巨大变化，不应以c#编写逻辑的思维方式去考量lua，所以在wLua2里找不到c#在lua的对应物，c#协程，MonoBehavior，Start，Updat... 这些统统没有。即便如此，也完全可以应对重度大型游戏。	
3. 基于lua5.3
	本人不建议大家使用luajit，尤其是客户端同学，它成为拙劣架构导致运行期低效的救命稻草,从而掩盖问题本身。由于后续lua版本的一些高级特性很难被luajit实现，所以作者不再实现lua5.2/5.3的兼容版本。而且luajit现在也没有实现c/c++间的异常问题（longjmp后堆栈中的c++对象无法析构，这就如同在c#中调用了lua_error，c#栈上的对象此时是个什么状态？）
4. 全新实现，代码结构和运行效率更进一步
	luaState类是对lua_State的基本封装，你可以在多个线程内创建多个实例，以实现不同目的。wLua类是对luaState类的封装，我假定wLua类是游戏逻辑使用的主要lua类，所以已经替你调用了很多初始化函数。在底层，我将__index从table改成了function，这使得我们可以做cache以便减少查找次数，在类型表的构建和父子类递归查询方面，巧妙使用upvalue，每个c#导出类，我只使用了一个function和一个table，而在wLua中，至少使用了3个table，使得系统初始化的lua capi调用次数也大大减少。不再支持属性的点访问写法，统一使用set_/get_函数调用实现。将所有类型和函数放入名字空间中，你可以在初始化时指定名字空间的名称（可以参见wLua类的Init函数）。

由于时间仓促，只编译和测试了windows平台的插件
